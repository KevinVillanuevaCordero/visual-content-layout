<?php

module_load_include('inc','visual_content_layout','includes/button');

/**
 * Builds a list of all swaps (for filter).
 *
 * Calls the swap_info hook with the list parameter on all module. Returns
 * the all defined and altered Shortcode definitions.
 */

function visual_content_layout_swaps_info() {
  $swaps = array();
  visual_content_layout_button_info($swaps);
  return $swaps;
}

/**
 * Implements hook_theme().
 */
function visual_content_layout_theme() {
  return array(
    'button' => array(
      'variables' => array('path' => NULL, 'text' => NULL, 'class' => NULL),
    ),
  );
}


function visual_content_layout_is_tag($tag, $swaps) {
  if (isset($swaps[$tag])) {
    return TRUE;
  }

  return FALSE;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/**
 * Generates a random code.
 *
 * Calling
 * [random length=X /]
 *
 * Where X is the length of the random text.
 * If the length empty or invalid, between 1-99, the length will be 8.
 */
function visual_content_layout_swap_random($attrs, $text) {
  $attrs = visual_content_layout_attrs(array(
    'length' => 8,
  ),
    $attrs
  );

  $length = intval($attrs['length']);
  if (($length < 0) || ($length > 99)) {
    $length = 8;
  }

  $text = '';
  for ($i = 0; $i < $length; ++$i) {
    $text .= chr(rand(32, 126));
  }

  return $text;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function _visual_content_layout($text, $filter) {
  
  //get all the tags and it attributes
  $swaps = visual_content_layout_swaps_info();
  $swaps_enabled = array();

  //get the name of all swaps
  $swaps_names = explode(" ", $filter->settings["allowed_swaps"]);

  foreach ($swaps_names as $name) {
    $name = substr($name,1,-1);
    if ($name && !empty($swaps[$name]['process callback'])) {
      $swaps_enabled[$name] = array(
        'function' => $swaps[$name]['process callback'],
      );
    }
  }

  if (empty($swaps_enabled)) {
    return $text;
  }

  // Processing recursively, now embedding tags within other tags is supported!
  $chunks = preg_split('!(\[{1,2}.*?\]{1,2})!', $text, -1, PREG_SPLIT_DELIM_CAPTURE);

  $heap = array();
  $heap_index = array();
  
  foreach ($chunks as $c) {
    if (!$c) {
      continue;
    }
    
    $escaped = FALSE;
    
    if ((substr($c, 0, 2) == '[[') && (substr($c, -2, 2) == ']]')) {
      $escaped = TRUE;
      // Checks media tags, eg: [[{ }]].
      if ((substr($c, 0, 3) != '{') && (substr($c, -3, 1) != '}')) {
        // Removes the outer [].
        $c = substr($c, 1, -1);
      }
    }
    // Decide this is a Shortcode tag or not.
    if (!$escaped && ($c[0] == '[') && (substr($c, -1, 1) == ']')) {
      // The $c maybe contains Shortcode macro.

      // This is maybe a self-closing tag.
      // Removes outer [].
      $original_text = $c;
      $c = substr($c, 1, -1);
      $c = trim($c);

      $ts = explode(' ', $c);
      $tag = array_shift($ts);
      $tag = trim($tag, '/');

      if (!visual_content_layout_is_tag($tag,$swaps)) {
        // The current tag is not enabled.
        array_unshift($heap_index, '_string_');
        array_unshift($heap, $original_text);
      }
      elseif (substr($c, -1, 1) == '/') {
        // Processes a self closing tag, - it has "/" at the end-
        /*
         * The exploded array elements meaning:
         * 0 - the full tag text?
         * 1/5 - An extra [] to allow for escaping Shortcodes with double [[]].
         * 2 - The Shortcode name.
         * 3 - The Shortcode argument list.
         * 4 - The content of a Shortcode when it wraps some content.
         */

        $m = array(
          $c,
          '',
          $tag,
          implode(' ', $ts),
          NULL,
          '',
        );
        array_unshift($heap_index, '_string_');
        array_unshift($heap, _visual_content_layout_process_tag($m,$swaps_enabled));
      }
      elseif ($c[0] == '/') {
        // Indicate a closing tag, so we process the heap.
        $closing_tag = substr($c, 1);

        $process_heap = array();
        $process_heap_index = array();
        $found = FALSE;

        // Get elements from heap and process.
        do {
          $tag = array_shift($heap_index);
          $heap_text = array_shift($heap);

          if ($closing_tag == $tag) {
            // Process the whole tag.
            $m = array(
              $tag . ' ' . $heap_text,
              '',
              $tag,
              $heap_text,
              implode('', $process_heap),
              '',
            );
            $str = _visual_content_layout_process_tag($m,$swaps_enabled);
            array_unshift($heap_index, '_string_');
            array_unshift($heap, $str);
            $found = TRUE;
          }
          else {
            array_unshift($process_heap, $heap_text);
            array_unshift($process_heap_index, $tag);
          }
        } while (!$found && $heap);

        if (!$found) {
          foreach ($process_heap as $val) {
            array_unshift($heap, $val);
          }
          foreach ($process_heap_index as $val) {
            array_unshift($heap_index, $val);
          }
        }

      }
      else {
        // This is a starting tag. Put it to the heap.
        array_unshift($heap_index, $tag);
        array_unshift($heap, implode(' ', $ts));
      }
      // If escaped or not a Shortcode.
    }
    else {
      // Maybe not found a pair?
      array_unshift($heap_index, '_string_');
      array_unshift($heap, $c);
    }
  }//end foreach

  return (implode('', array_reverse($heap)));
}


/**
 * Regular Expression callable for do_shortcode() for calling Shortcode hook.
 *
 * See for details of the match array contents.
 *
 * @param array $m
 *   Regular expression match array.
 *
 * @return mixed
 *   False on failure.
 */
function _visual_content_layout_process_tag($m, $swaps) {

  $tag = $m[2];

  if (!empty($swaps[$tag])) {
    // Process if tag exists (enabled).
    $attr = _visual_content_layout_parse_attrs($m[3]);
    /*
    * 0 - the full tag text?
    * 1/5 - An extra [ or ] to allow for escaping shortcodes with double [[]]
    * 2 - The Shortcode name
    * 3 - The Shortcode argument list
    * 4 - The content of a Shortcode when it wraps some content.
    * */

    if (!is_null($m[4])) {
      // This is an enclosing tag, means extra parameter is present.
      if (is_string($swaps[$tag]['function']) && function_exists($swaps[$tag]['function'])) {
        return $m[1] . call_user_func($swaps[$tag]['function'], $attr, $m[4], $m[2]) . $m[5];
      }
      return $m[1] . $m[5];
    }
    else {
      // This is a self-closing tag.
      if (is_string($swaps[$tag]['function']) && function_exists($swaps[$tag]['function'])) {
        return $m[1] . call_user_func($swaps[$tag]['function'], $attr, NULL, $m[2]) . $m[5];
      }
      return $m[1] . $m[5];
    }
  }
  elseif (is_null($m[4])) {
    return $m[4];
  }
  return '';
}


/**
 * Retrieve all attributes from the Shortcodes tag.
 *
 * The attributes list has the attribute name as the key and the value of the
 * attribute as the value in the key/value pair. This allows for easier
 * retrieval of the attributes, since all attributes have to be known.
 *
 * @param string $text
 *   The Shortcode tag attribute line.
 *
 * @return array
 *   List of attributes and their value.
 */
function _visual_content_layout_parse_attrs($text) {
  $attrs = array();
  $pattern = '/(\w+)\s*=\s*"([^"]*)"(?:\s|$)|(\w+)\s*=\s*\'([^\']*)\'(?:\s|$)|(\w+)\s*=\s*([^\s\'"]+)(?:\s|$)|"([^"]*)"(?:\s|$)|(\S+)(?:\s|$)/';
  $text = preg_replace("/[\x{00a0}\x{200b}]+/u", " ", $text);
  $text = html_entity_decode($text);
  if (preg_match_all($pattern, $text, $match, PREG_SET_ORDER)) {
    foreach ($match as $m) {
      if (!empty($m[1])) {
        $attrs[strtolower($m[1])] = stripcslashes($m[2]);
      }
      elseif (!empty($m[3])) {
        $attrs[strtolower($m[3])] = stripcslashes($m[4]);
      }
      elseif (!empty($m[5])) {
        $attrs[strtolower($m[5])] = stripcslashes($m[6]);
      }
      elseif (isset($m[7]) and strlen($m[7])) {
        $attrs[] = stripcslashes($m[7]);
      }
      elseif (isset($m[8])) {
        $attrs[] = stripcslashes($m[8]);
      }
    }
  }
  else {
    $attrs = ltrim($text);
  }
  return $attrs;
}


/**
 * Combines user attributes with known attributes.
 *
 * The pairs should be considered to be all of the attributes which are
 * supported by the caller and given as a list. The returned attributes will
 * only contain the attributes in the $pairs list.
 *
 * If the $attrs list has unsupported attributes, then they will be ignored and
 * removed from the final return list.
 *
 * @param array $pairs
 *   Entire list of supported attributes and their defaults.
 *
 * @param array $attrs
 *   User defined attributes in Shortcode tag.
 *
 * @return array
 *   Combined and filtered attribute list.
 */
function visual_content_layout_attrs($pairs, $attrs) {
  $attrs = (array) $attrs;
  $out = array();
  foreach ($pairs as $name => $default) {
    if (array_key_exists($name, $attrs)) {
      $out[$name] = $attrs[$name];
    }
    else {
      $out[$name] = $default;
    }
  }
  return $out;
}

/**
 * Provides a class parameter helper function.
 *
 * @param mixed $class
 *   The class string or array
 *
 * @param string $default
 *   The default class value.
 *
 * @return string
 *   The proper classes string.
 */
function visual_content_layout_add_class($class = '', $default = '') {
  if ($class) {
    if (!is_array($class)) {
      $class = explode(' ', $class);
    }
    array_unshift($class, $default);
    $class = array_unique($class);
  }
  else {
    $class[] = $default;
  }
  return implode(' ', $class);
}
