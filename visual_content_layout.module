<?php

use \Drupal\visual_content_layout\Plugin\Swap\Button;
use \Drupal\visual_content_layout\VisualContentLayoutSwapper;

/**
 * Builds a list of all swaps (for filter).
 *
 * Calls the swap_info hook with the list parameter on all module. Returns
 * the all defined and altered Shortcode definitions.
 */

function visual_content_layout_swaps_info() {
  $swaps = array();
  visual_content_layout_button_info($swaps);
  return $swaps;
}

/**
 * Implements hook_theme().
 */
function visual_content_layout_theme() {
  return array(
    'button' => array(
      'variables' => array('path' => NULL, 'text' => NULL, 'class' => NULL),
    ),
  );
}


function visual_content_layout_is_tag($tag, $swaps) {
  if (isset($swaps[$tag])) {
    return TRUE;
  }

  return FALSE;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/**
 * Generates a random code.
 *
 * Calling
 * [random length=X /]
 *
 * Where X is the length of the random text.
 * If the length empty or invalid, between 1-99, the length will be 8.
 */
function visual_content_layout_swap_random($attrs, $text) {
  $attrs = visual_content_layout_attrs(array(
    'length' => 8,
  ),
    $attrs
  );

  $length = intval($attrs['length']);
  if (($length < 0) || ($length > 99)) {
    $length = 8;
  }

  $text = '';
  for ($i = 0; $i < $length; ++$i) {
    $text .= chr(rand(32, 126));
  }

  return $text;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function _visual_content_layout($text, $filter) {

  $text = VisualContentLayoutSwapper::swap_process($text);

  return $text;

}


/**
 * Regular Expression callable for do_shortcode() for calling Shortcode hook.
 *
 * See for details of the match array contents.
 *
 * @param array $m
 *   Regular expression match array.
 *
 * @return mixed
 *   False on failure.
 */
function _visual_content_layout_process_tag($m, $swaps) {

  $tag = $m[2];

  if (!empty($swaps[$tag])) {
    // Process if tag exists (enabled).
    $attr = _visual_content_layout_parse_attrs($m[3]);
    /*
    * 0 - the full tag text?
    * 1/5 - An extra [ or ] to allow for escaping shortcodes with double [[]]
    * 2 - The Shortcode name
    * 3 - The Shortcode argument list
    * 4 - The content of a Shortcode when it wraps some content.
    * */

    if (!is_null($m[4])) {
      // This is an enclosing tag, means extra parameter is present.
      if (is_string($swaps[$tag]['function']) && function_exists($swaps[$tag]['function'])) {
        return $m[1] . call_user_func($swaps[$tag]['function'], $attr, $m[4], $m[2]) . $m[5];
      }
      return $m[1] . $m[5];
    }
    else {
      // This is a self-closing tag.
      if (is_string($swaps[$tag]['function']) && function_exists($swaps[$tag]['function'])) {
        return $m[1] . call_user_func($swaps[$tag]['function'], $attr, NULL, $m[2]) . $m[5];
      }
      return $m[1] . $m[5];
    }
  }
  elseif (is_null($m[4])) {
    return $m[4];
  }
  return '';
}


/**
 * Retrieve all attributes from the Shortcodes tag.
 *
 * The attributes list has the attribute name as the key and the value of the
 * attribute as the value in the key/value pair. This allows for easier
 * retrieval of the attributes, since all attributes have to be known.
 *
 * @param string $text
 *   The Shortcode tag attribute line.
 *
 * @return array
 *   List of attributes and their value.
 */
function _visual_content_layout_parse_attrs($text) {
  $attrs = array();
  $pattern = '/(\w+)\s*=\s*"([^"]*)"(?:\s|$)|(\w+)\s*=\s*\'([^\']*)\'(?:\s|$)|(\w+)\s*=\s*([^\s\'"]+)(?:\s|$)|"([^"]*)"(?:\s|$)|(\S+)(?:\s|$)/';
  $text = preg_replace("/[\x{00a0}\x{200b}]+/u", " ", $text);
  $text = html_entity_decode($text);
  if (preg_match_all($pattern, $text, $match, PREG_SET_ORDER)) {
    foreach ($match as $m) {
      if (!empty($m[1])) {
        $attrs[strtolower($m[1])] = stripcslashes($m[2]);
      }
      elseif (!empty($m[3])) {
        $attrs[strtolower($m[3])] = stripcslashes($m[4]);
      }
      elseif (!empty($m[5])) {
        $attrs[strtolower($m[5])] = stripcslashes($m[6]);
      }
      elseif (isset($m[7]) and strlen($m[7])) {
        $attrs[] = stripcslashes($m[7]);
      }
      elseif (isset($m[8])) {
        $attrs[] = stripcslashes($m[8]);
      }
    }
  }
  else {
    $attrs = ltrim($text);
  }
  return $attrs;
}


/**
 * Combines user attributes with known attributes.
 *
 * The pairs should be considered to be all of the attributes which are
 * supported by the caller and given as a list. The returned attributes will
 * only contain the attributes in the $pairs list.
 *
 * If the $attrs list has unsupported attributes, then they will be ignored and
 * removed from the final return list.
 *
 * @param array $pairs
 *   Entire list of supported attributes and their defaults.
 *
 * @param array $attrs
 *   User defined attributes in Shortcode tag.
 *
 * @return array
 *   Combined and filtered attribute list.
 */
function visual_content_layout_attrs($pairs, $attrs) {
  $attrs = (array) $attrs;
  $out = array();
  foreach ($pairs as $name => $default) {
    if (array_key_exists($name, $attrs)) {
      $out[$name] = $attrs[$name];
    }
    else {
      $out[$name] = $default;
    }
  }
  return $out;
}

/**
 * Provides a class parameter helper function.
 *
 * @param mixed $class
 *   The class string or array
 *
 * @param string $default
 *   The default class value.
 *
 * @return string
 *   The proper classes string.
 */
function visual_content_layout_add_class($class = '', $default = '') {
  if ($class) {
    if (!is_array($class)) {
      $class = explode(' ', $class);
    }
    array_unshift($class, $default);
    $class = array_unique($class);
  }
  else {
    $class[] = $default;
  }
  return implode(' ', $class);
}
